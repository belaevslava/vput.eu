jQuery(document).ready(function ($) {
    $('[data-toggle=tooltip]').tooltip();
    $('[data-toggle=popover]').popover();
    setTimeout(function () {
        $('.page-preloader').fadeOut(700);
    }, 1);
});
// let app = new Vue({
//     el: '#app',
//     methods: {
//         getLocalStorageItem: function(keyName) {
//             return JSON.parse(localStorage.getItem(keyName));
//         },
//         setLocalStorageItem: function(keyName, value) {
//             localStorage.setItem(keyName, JSON.stringify(value));
//         },
//         addToFavorites: function(offerId) {
//             let favorites = this.getLocalStorageItem('favorites');
//             favorites = Array.isArray(favorites) ? favorites : [];
//             favorites.push(offerId);
//             this.setLocalStorageItem('favorites', favorites);
//         },
//         removeFromFavorites: function(offerId) {
//             let favorites = this.getLocalStorageItem('favorites');
//             favorites = Array.isArray(favorites) ? favorites : [];
//
//             let indexOfRemovedElement = favorites.indexOf(offerId);
//             favorites.splice(indexOfRemovedElement, 1);
//
//             this.setLocalStorageItem('favorites', favorites);
//         },
//         toggleFavorites: function(offerId) {
//             this.addToFavorites(offerId);
//         }
//     }
// });
jQuery(document).ready(function ($) {
    var blockElement = $('.cities-tabs');
    function setCitiesLetters(contentElement) {
        var usedLetters = [];
        contentElement.find('[data-name]').each(function (index, element) {
            var $element = $(element), cityName = $element.data('name'), cityNameFirstLetter = cityName.substring(0, 1).toUpperCase(), usedLettersHasCurrentLetter = usedLetters.indexOf(cityNameFirstLetter) > -1;
            if (usedLettersHasCurrentLetter)
                return true;
            usedLetters.push(cityNameFirstLetter);
            $element.attr('data-letter', cityNameFirstLetter);
        });
    }
    blockElement.find('.tab-pane').each(function (index, element) {
        setCitiesLetters($(element));
    });
});
jQuery(document).ready(function ($) {
    var blockElement = $('.offer-image-slider');
    blockElement.find('[is-slider]').slick({
        slidesToShow: 1,
        slidesToScroll: 1,
        arrows: true,
        asNavFor: '.offer-image-slider [is-slider-nav]'
    });
    blockElement.find('[is-slider-nav]').slick({
        slidesToShow: 10,
        slidesToScroll: 1,
        asNavFor: '.offer-image-slider [is-slider]',
        dots: false,
        arrows: false,
        focusOnSelect: true,
        responsive: [
            {
                breakpoint: 1300,
                settings: {
                    slidesToShow: 7
                }
            },
            {
                breakpoint: 992,
                settings: {
                    slidesToShow: 5
                }
            },
            {
                breakpoint: 768,
                settings: {
                    slidesToShow: 4
                }
            },
            {
                breakpoint: 480,
                settings: {
                    slidesToShow: 2
                }
            }
        ]
    });
});
jQuery(document).ready(function ($) {
    var blockElement = $('.offer-item');
    blockElement.find('.offer-item__arrow').on('click', function () {
        var arrowElement = $(this), sliderElement = arrowElement.closest('.offer-item__image-slider'), slickSliderElement = sliderElement.find('.offer-item__list-of-images[is-slick-carousel]');
        slickSliderElement.slick({
            infinite: true,
            dots: false
        });
        slickSliderElement.find('[data-src]').each(function () {
            var slideElement = $(this), imageSource = slideElement.attr('data-src');
            slideElement.css('background-image', 'url(' + imageSource + ')');
        });
        slickSliderElement.remove('.offer-item__arrow');
        if (arrowElement.hasClass('offer-item__arrow_slide_prev')) {
            slickSliderElement.slick('slickPrev');
        }
        else {
            slickSliderElement.slick('slickNext');
        }
    });
    blockElement
        .find('.offer-item__add-to-favorites[data-toggle="button"]')
        .on('click', function () {
        $(this).toggleClass('active');
    });
});
// Данный класс должен содержать методы:
// start,stop,title, init
// Таким образом он будет без ошибок работать в классах form, selects, buttons
var loaderBlock = function (image) {
    this.loadingBlock = '.ajax_block';
    this.title = '.loaderTitle';
    this.started = false;
    this.image = image || '/images/loaders/vput/xxs.gif';
    this.id = '';
    this.img$ = $('<div class="ajax_block_img"><img src="' + this.image + '"/></div>');
    this.title$ = $('<span class="' + this.title.replace('.', '') + '"></span>');
    this.bg$ = $('<div class="' + this.loadingBlock.replace('.', '') + '">&nbsp;</div>').css({ 'position': 'absolute', 'display': 'none' });
    this.destination = 'body';
    this.useCircle = function () {
        this.img$.addClass('useCircle');
        return this;
    };
    this.init = function (object$) {
        if (this.targetIsOnPage(object$)) {
            if (!this.issetTarget()) {
                this.setTarget(object$);
            }
            this.id = 'loaderBlock-' + $('.ajax_block').length;
            this.img$
                .css('opacity', 1)
                .find('img')
                .attr('src', this.image);
            this.bg$
                .attr('id', this.id)
                .css(this.getParameters())
                .append(this.img$.append(this.title$)).appendTo(this.destination);
        }
        return this;
    };
    this.targetIsOnPage = function (object$) {
        return $('body').find(object$).length > 0;
    };
    this.issetTarget = function () {
        return this.target$ !== undefined;
    };
    this.setTarget = function (object$) {
        if (object$ === undefined) {
            alert('You must specify the object which will be imposed loading');
        }
        this.target$ = object$;
        return this;
    };
    this.getTarget = function () {
        if ($(this.target$).length === 0) {
            this.setTarget($(this.target$.selector));
            if ($(this.target$).length === 0) {
                alert('Selector ' + this.target$.selector + ' choosed no one object');
                return this;
            }
        }
        return this.target$;
    };
    this.start = function () {
        if (this.started) {
            return;
        }
        this.started = true;
        this.bg$.css(this.getParameters());
        $('#' + this.id).fadeIn(300);
        this.getTarget().stop(true, true).css({ 'opacity': .3 });
        this.getTarget().find('select').attr('disabled', 'disabled');
        return this;
    };
    this.stop = function () {
        var that = this;
        $('#' + this.id).stop(true, true).hide(100, function () {
            $(this).css('display', 'none');
            that.getTarget().stop(true, true).css({ 'opacity': 1 });
            that.getTarget().find('select, input, textarea').removeAttr('disabled');
        });
        this.started = false;
        return this;
    };
    this.getParameters = function () {
        var object$ = this.getTarget();
        var parameters = {
            'width': object$.outerWidth(),
            'height': object$.outerHeight(),
            'top': object$.offset().top,
            'left': object$.offset().left
        };
        return parameters;
    };
    this.title = function (title) {
        $(this.loadingBlock + ' ' + this.title).text(title);
        return this;
    };
};
var maps = function (settings) {
    this.mapPlace = 'googleMaps';
    this.settings = $.extend({
        'center': new google.maps.LatLng(-34.397, 150.644),
        'zoom': 15
    }, settings || {});
    this.setMapPlace = function (id) {
        if (typeof id === 'undefined') {
            alert('Please send object id for map placement');
        }
        this.mapPlace = id;
        return this;
    };
    this.setSettings = function (settings) {
        this.settings = $.extend(this.settings, settings || {});
        return this;
    };
    this.createMap = function () {
        var that = this;
        that.setMap();
        return this;
    };
    this.setMap = function () {
        var that = this;
        this.map = new google.maps.Map(document.getElementById(that.mapPlace), that.settings);
        return this;
    };
    this.getMap = function () {
        if (this.map === undefined)
            this.setMap();
        return this.map;
    };
    this.setCenterByAddress = function (address) {
        var that = this;
        address = $.trim(address);
        var geocoder = new google.maps.Geocoder();
        geocoder.geocode({ 'address': address }, function (results, status) {
            if (status == google.maps.GeocoderStatus.OK) {
                that.createDraggMarker(results[0].geometry.location)
                    .getMap().setCenter(results[0].geometry.location);
            }
        });
    };
    this.removeMarkers = function () {
        if (typeof this.marker !== 'undefined')
            this.marker.setMap(null);
        if (typeof this.draggMarker !== 'undefined')
            this.draggMarker.setMap(null);
        return this;
    };
    this.createMarker = function (loc) {
        var that = this;
        this.removeMarkers();
        var geocoder = new google.maps.Geocoder();
        geocoder.geocode({ 'address': loc }, function (results, status) {
            if (status == google.maps.GeocoderStatus.OK)
                var place = results[0].geometry.location;
            else {
                var place = new google.maps.LatLng(42.71099706708453, 27.756775543066396);
                that.getMap().setOptions({ 'zoom': 7 });
            }
            that.removeMarkers();
            this.marker = new google.maps.Marker({
                position: place,
                map: that.getMap(),
                draggable: false
            });
            that.getMap().setCenter(place);
        });
        return this;
    };
    this.createMarkerByLatLng = function (lat, lng) {
        var that = this;
        this.removeMarkers();
        var loc = new google.maps.LatLng(parseFloat(lat), parseFloat(lng));
        this.marker = new google.maps.Marker({
            position: loc,
            map: that.getMap()
        });
        that.getMap().setCenter(loc);
        return this;
    };
    this.createDraggMarker = function (loc, draggEnd, infoWindow) {
        var that = this;
        loc = $.trim(loc);
        var geocoder = new google.maps.Geocoder();
        geocoder.geocode({ 'address': loc }, function (results, status) {
            if (status == google.maps.GeocoderStatus.OK)
                var place = results[0].geometry.location;
            else {
                var place = new google.maps.LatLng(42.71099706708453, 27.756775543066396);
                that.getMap().setOptions({ 'zoom': 7 });
            }
            that.removeMarkers();
            that.draggMarker = new google.maps.Marker({
                position: place,
                map: that.getMap(),
                draggable: true
            });
            if (typeof infoWindow == 'object') {
                infoWindow.open(that.map, that.draggMarker);
                google.maps.event.addListener(that.draggMarker, 'click', function () {
                    infoWindow.open(that.map, that.draggMarker);
                });
            }
            google.maps.event.addListener(that.draggMarker, 'dragend', draggEnd);
            that.getMap().setCenter(place);
        });
        return this;
    };
    this.createDraggMarkerByLatLng = function (Lat, Lng, draggEnd, infoWindow) {
        var that = this;
        var loc = new google.maps.LatLng(parseFloat(Lat), parseFloat(Lng));
        that.draggMarker = new google.maps.Marker({
            position: loc,
            map: that.getMap(),
            draggable: true
        });
        if (typeof infoWindow == 'object') {
            infoWindow.open(that.map, that.draggMarker);
            google.maps.event.addListener(that.draggMarker, 'click', function () {
                infoWindow.open(that.map, that.draggMarker);
            });
        }
        google.maps.event.addListener(that.draggMarker, 'dragend', draggEnd);
        that.getMap().setCenter(loc);
        //			var geocoder = new google.maps.Geocoder();
        //			geocoder.geocode( { 'address':loc}, function(results, status) {
        //				if (status == google.maps.GeocoderStatus.OK)
        //					var place = results[0].geometry.location;
        //				else {
        //					var place = new google.maps.LatLng(42.71099706708453, 27.756775543066396);
        //					that.getMap().setOptions({'zoom': 7});
        //				}
        //
        //				that.removeMarkers();
        //
        //			});
        return this;
    };
};
var MetrikaGoals = function () {
    var goals = {
        0: 'reservation_prepay_clk',
        1: 'reservation_prepay_sel',
        2: 'reservation_trust_clk',
        3: 'reservation_trust_hover',
        4: 'reservation_warn_link_clk',
        5: 'reservation_complete_clk',
        6: 'reservation_smo_clk',
        7: 'reservation_manual_profile_clk',
        8: 'objects_list_view',
        9: 'conv_prep_clk',
        10: 'conv_prep_sel',
        11: 'conv_trust_clk',
        12: 'conv_trust_hover',
        13: 'conv_warn_link_clk',
        14: 'conv_complete_btn_clk',
        15: 'conv_smo_btn_clk',
        16: 'conv_profile_manual_clk',
        17: 'filter_sveti_vlas',
        18: 'filter_sunny_beach',
        19: 'filter_sozopol',
        20: 'filter_nesebr',
        21: 'filter_varna',
        22: 'filter_golden_sands',
        23: 'filter_biala',
        24: 'filter_pomorie',
        25: 'land_top_destination',
        26: 'land_mov_how_it_works',
        27: 'land_how_to_get',
        28: 'land_attractions',
        29: 'search_2guests',
        30: 'search_3guests',
        31: 'search_4guests',
        32: 'search_5guests',
        33: 'search_date_june',
        34: 'search_date_july',
        35: 'search_date_aug',
        36: 'search_date_sept',
        37: 'booking_paid',
        38: 'search_6guests',
        39: 'search_m6_guests',
        40: 'authorization',
        41: 'registration',
        42: 'auth_page_visit',
        43: 'reviews_login_action',
        44: 'reviews_publish_action',
        45: 'calendar_actuality_action',
        46: 'no_occupied_click'
    };
    var counterNm = {};
    this.reachGoal = function (goalName) {
        if (goalExist(goalName)) {
            var goalIdentifier = goals[goalName];
            if (typeof yaCounter25232657 !== 'undefined') {
                counterNm = yaCounter25232657;
                counterNm.reachGoal(goalIdentifier);
            }
            if (typeof ga !== 'undefined') {
                ga('send', 'event', 'General', goalIdentifier);
            }
        }
    };
    var goalExist = function (goalName) {
        if (typeof goals[goalName] === 'undefined') {
            return false;
        }
        else {
            return true;
        }
    };
    function dump(obj) {
        var out = '';
        for (var i in obj) {
            out += i + ": " + obj[i] + "\n";
        }
        alert(out);
    }
};
$(function () {
    var zoomer = mapsZoomer(realtiesOnMap.map);
    google.maps.event.addListener(realtiesOnMap.map, 'zoom_changed', function () {
        mapsZoomer.current = realtiesOnMap.map.getZoom();
        if (zoomer.isMax()) {
            $('.plusSizeMap').addClass('disabled');
        }
        if (!zoomer.isMin()) {
            $('.minusSizeMap').removeClass('disabled');
        }
        if (zoomer.isMin()) {
            $('.minusSizeMap').addClass('disabled');
        }
        if (!zoomer.isMax()) {
            $('.plusSizeMap').removeClass('disabled');
        }
    });
    google.maps.event.addListener(realtiesOnMap.map, 'click', function () {
        markers.closeWindows();
    });
    $('.plusSizeMap').click(function () {
        zoomer.zoomIn();
    });
    $('.minusSizeMap').click(function () {
        zoomer.zoomOut();
    });
    $('.mapDomination').click(function () {
        $('.main').toggleClass('bigMap');
        $('.imgOffersBlock').css('height', 'auto');
        google.maps.event.trigger(realtiesOnMap.map, "resize");
    });
});
$(function () {
    realtiesOnMap.initialize()
        .setCenter({ 'name': $('#map-canvas').data('center') })
        .setQuery(location.search.replace('?', ''))
        .setZoom(parseInt(hashHandler.getJsonHash().zoom) || 13);
});
/**
 * @name InfoBox
 * @version 1.1.13 [March 19, 2014]
 * @author Gary Little (inspired by proof-of-concept code from Pamela Fox of Google)
 * @copyright Copyright 2010 Gary Little [gary at luxcentral.com]
 * @fileoverview InfoBox extends the Google Maps JavaScript API V3 <tt>OverlayView</tt> class.
 *  <p>
 *  An InfoBox behaves like a <tt>google.maps.InfoWindow</tt>, but it supports several
 *  additional properties for advanced styling. An InfoBox can also be used as a map label.
 *  <p>
 *  An InfoBox also fires the same events as a <tt>google.maps.InfoWindow</tt>.
 */
/*!
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*jslint browser:true */
/*global google */
/**
 * @name InfoBoxOptions
 * @class This class represents the optional parameter passed to the {@link InfoBox} constructor.
 * @property {string|Node} content The content of the InfoBox (plain text or an HTML DOM node).
 * @property {boolean} [disableAutoPan=false] Disable auto-pan on <tt>open</tt>.
 * @property {number} maxWidth The maximum width (in pixels) of the InfoBox. Set to 0 if no maximum.
 * @property {Size} pixelOffset The offset (in pixels) from the top left corner of the InfoBox
 *  (or the bottom left corner if the <code>alignBottom</code> property is <code>true</code>)
 *  to the map pixel corresponding to <tt>position</tt>.
 * @property {LatLng} position The geographic location at which to display the InfoBox.
 * @property {number} zIndex The CSS z-index style value for the InfoBox.
 *  Note: This value overrides a zIndex setting specified in the <tt>boxStyle</tt> property.
 * @property {string} [boxClass="infoBox"] The name of the CSS class defining the styles for the InfoBox container.
 * @property {Object} [boxStyle] An object literal whose properties define specific CSS
 *  style values to be applied to the InfoBox. Style values defined here override those that may
 *  be defined in the <code>boxClass</code> style sheet. If this property is changed after the
 *  InfoBox has been created, all previously set styles (except those defined in the style sheet)
 *  are removed from the InfoBox before the new style values are applied.
 * @property {string} closeBoxMargin The CSS margin style value for the close box.
 *  The default is "2px" (a 2-pixel margin on all sides).
 * @property {string} closeBoxURL The URL of the image representing the close box.
 *  Note: The default is the URL for Google's standard close box.
 *  Set this property to "" if no close box is required.
 * @property {Size} infoBoxClearance Minimum offset (in pixels) from the InfoBox to the
 *  map edge after an auto-pan.
 * @property {boolean} [isHidden=false] Hide the InfoBox on <tt>open</tt>.
 *  [Deprecated in favor of the <tt>visible</tt> property.]
 * @property {boolean} [visible=true] Show the InfoBox on <tt>open</tt>.
 * @property {boolean} alignBottom Align the bottom left corner of the InfoBox to the <code>position</code>
 *  location (default is <tt>false</tt> which means that the top left corner of the InfoBox is aligned).
 * @property {string} pane The pane where the InfoBox is to appear (default is "floatPane").
 *  Set the pane to "mapPane" if the InfoBox is being used as a map label.
 *  Valid pane names are the property names for the <tt>google.maps.MapPanes</tt> object.
 * @property {boolean} enableEventPropagation Propagate mousedown, mousemove, mouseover, mouseout,
 *  mouseup, click, dblclick, touchstart, touchend, touchmove, and contextmenu events in the InfoBox
 *  (default is <tt>false</tt> to mimic the behavior of a <tt>google.maps.InfoWindow</tt>). Set
 *  this property to <tt>true</tt> if the InfoBox is being used as a map label.
 */
/**
 * Creates an InfoBox with the options specified in {@link InfoBoxOptions}.
 *  Call <tt>InfoBox.open</tt> to add the box to the map.
 * @constructor
 * @param {InfoBoxOptions} [opt_opts]
 */
function InfoBox(opt_opts) {
    opt_opts = opt_opts || {};
    google.maps.OverlayView.apply(this, arguments);
    // Standard options (in common with google.maps.InfoWindow):
    //
    this.content_ = opt_opts.content || "";
    this.disableAutoPan_ = opt_opts.disableAutoPan || false;
    this.maxWidth_ = opt_opts.maxWidth || 0;
    this.pixelOffset_ = opt_opts.pixelOffset || new google.maps.Size(0, 0);
    this.position_ = opt_opts.position || new google.maps.LatLng(0, 0);
    this.zIndex_ = opt_opts.zIndex || null;
    // Additional options (unique to InfoBox):
    //
    this.onOpen = opt_opts.onOpen || function () { };
    this.boxClass_ = opt_opts.boxClass || "infoBox";
    this.boxStyle_ = opt_opts.boxStyle || {};
    this.closeBoxMargin_ = opt_opts.closeBoxMargin || "2px";
    this.closeBoxURL_ = opt_opts.closeBoxURL || "https://www.google.com/intl/en_us/mapfiles/close.gif";
    if (opt_opts.closeBoxURL === "") {
        this.closeBoxURL_ = "";
    }
    this.infoBoxClearance_ = opt_opts.infoBoxClearance || new google.maps.Size(1, 1);
    if (typeof opt_opts.visible === "undefined") {
        if (typeof opt_opts.isHidden === "undefined") {
            opt_opts.visible = true;
        }
        else {
            opt_opts.visible = !opt_opts.isHidden;
        }
    }
    this.isHidden_ = !opt_opts.visible;
    this.alignBottom_ = opt_opts.alignBottom || false;
    this.pane_ = opt_opts.pane || "floatPane";
    this.enableEventPropagation_ = opt_opts.enableEventPropagation || false;
    this.div_ = null;
    this.closeListener_ = null;
    this.moveListener_ = null;
    this.contextListener_ = null;
    this.eventListeners_ = null;
    this.fixedWidthSet_ = null;
}
/* InfoBox extends OverlayView in the Google Maps API v3.
 */
InfoBox.prototype = new google.maps.OverlayView();
/**
 * Creates the DIV representing the InfoBox.
 * @private
 */
InfoBox.prototype.createInfoBoxDiv_ = function () {
    var i;
    var events;
    var bw;
    var me = this;
    // This handler prevents an event in the InfoBox from being passed on to the map.
    //
    var cancelHandler = function (e) {
        e.cancelBubble = true;
        if (e.stopPropagation) {
            e.stopPropagation();
        }
    };
    // This handler ignores the current event in the InfoBox and conditionally prevents
    // the event from being passed on to the map. It is used for the contextmenu event.
    //
    var ignoreHandler = function (e) {
        e.returnValue = false;
        if (e.preventDefault) {
            e.preventDefault();
        }
        if (!me.enableEventPropagation_) {
            cancelHandler(e);
        }
    };
    if (!this.div_) {
        this.div_ = document.createElement("div");
        this.setBoxStyle_();
        if (typeof this.content_.nodeType === "undefined") {
            this.div_.innerHTML = this.getCloseBoxImg_() + this.content_;
        }
        else {
            this.div_.innerHTML = this.getCloseBoxImg_();
            this.div_.appendChild(this.content_);
        }
        // Add the InfoBox DIV to the DOM
        this.getPanes()[this.pane_].appendChild(this.div_);
        this.addClickHandler_();
        if (this.div_.style.width) {
            this.fixedWidthSet_ = true;
        }
        else {
            if (this.maxWidth_ !== 0 && this.div_.offsetWidth > this.maxWidth_) {
                this.div_.style.width = this.maxWidth_;
                this.div_.style.overflow = "auto";
                this.fixedWidthSet_ = true;
            }
            else { // The following code is needed to overcome problems with MSIE
                bw = this.getBoxWidths_();
                this.div_.style.width = (this.div_.offsetWidth - bw.left - bw.right) + "px";
                this.fixedWidthSet_ = false;
            }
        }
        this.panBox_(this.disableAutoPan_);
        if (!this.enableEventPropagation_) {
            this.eventListeners_ = [];
            // Cancel event propagation.
            //
            // Note: mousemove not included (to resolve Issue 152)
            events = ["mousedown", "mouseover", "mouseout", "mouseup",
                "click", "dblclick", "touchstart", "touchend", "touchmove"];
            for (i = 0; i < events.length; i++) {
                this.eventListeners_.push(google.maps.event.addDomListener(this.div_, events[i], cancelHandler));
            }
            // Workaround for Google bug that causes the cursor to change to a pointer
            // when the mouse moves over a marker underneath InfoBox.
            this.eventListeners_.push(google.maps.event.addDomListener(this.div_, "mouseover", function (e) {
                this.style.cursor = "default";
            }));
        }
        this.contextListener_ = google.maps.event.addDomListener(this.div_, "contextmenu", ignoreHandler);
        /**
         * This event is fired when the DIV containing the InfoBox's content is attached to the DOM.
         * @name InfoBox#domready
         * @event
         */
        google.maps.event.trigger(this, "domready");
        this.onOpen(this);
    }
};
/**
 * Returns the HTML <IMG> tag for the close box.
 * @private
 */
InfoBox.prototype.getCloseBoxImg_ = function () {
    var img = "";
    if (this.closeBoxURL_ !== "") {
        img = "<img";
        img += " src='" + this.closeBoxURL_ + "'";
        img += " align=right"; // Do this because Opera chokes on style='float: right;'
        img += " style='";
        img += " position: relative;"; // Required by MSIE
        img += " cursor: pointer;";
        img += " margin: " + this.closeBoxMargin_ + ";";
        img += "'>";
    }
    return img;
};
/**
 * Adds the click handler to the InfoBox close box.
 * @private
 */
InfoBox.prototype.addClickHandler_ = function () {
    var closeBox;
    if (this.closeBoxURL_ !== "") {
        closeBox = this.div_.firstChild;
        this.closeListener_ = google.maps.event.addDomListener(closeBox, "click", this.getCloseClickHandler_());
    }
    else {
        this.closeListener_ = null;
    }
};
/**
 * Returns the function to call when the user clicks the close box of an InfoBox.
 * @private
 */
InfoBox.prototype.getCloseClickHandler_ = function () {
    var me = this;
    return function (e) {
        // 1.0.3 fix: Always prevent propagation of a close box click to the map:
        e.cancelBubble = true;
        if (e.stopPropagation) {
            e.stopPropagation();
        }
        /**
         * This event is fired when the InfoBox's close box is clicked.
         * @name InfoBox#closeclick
         * @event
         */
        google.maps.event.trigger(me, "closeclick");
        me.close();
    };
};
/**
 * Pans the map so that the InfoBox appears entirely within the map's visible area.
 * @private
 */
InfoBox.prototype.panBox_ = function (disablePan) {
    var map;
    var bounds;
    var xOffset = 0, yOffset = 0;
    if (!disablePan) {
        map = this.getMap();
        if (map instanceof google.maps.Map) { // Only pan if attached to map, not panorama
            if (!map.getBounds().contains(this.position_)) {
                // Marker not in visible area of map, so set center
                // of map to the marker position first.
                map.setCenter(this.position_);
            }
            bounds = map.getBounds();
            var mapDiv = map.getDiv();
            var mapWidth = mapDiv.offsetWidth;
            var mapHeight = mapDiv.offsetHeight;
            var iwOffsetX = this.pixelOffset_.width;
            var iwOffsetY = this.pixelOffset_.height;
            var iwWidth = this.div_.offsetWidth;
            var iwHeight = this.div_.offsetHeight;
            var padX = this.infoBoxClearance_.width;
            var padY = this.infoBoxClearance_.height;
            var pixPosition = this.getProjection().fromLatLngToContainerPixel(this.position_);
            if (pixPosition.x < (-iwOffsetX + padX)) {
                xOffset = pixPosition.x + iwOffsetX - padX;
            }
            else if ((pixPosition.x + iwWidth + iwOffsetX + padX) > mapWidth) {
                xOffset = pixPosition.x + iwWidth + iwOffsetX + padX - mapWidth;
            }
            if (this.alignBottom_) {
                if (pixPosition.y < (-iwOffsetY + padY + iwHeight)) {
                    yOffset = pixPosition.y + iwOffsetY - padY - iwHeight;
                }
                else if ((pixPosition.y + iwOffsetY + padY) > mapHeight) {
                    yOffset = pixPosition.y + iwOffsetY + padY - mapHeight;
                }
            }
            else {
                if (pixPosition.y < (-iwOffsetY + padY)) {
                    yOffset = pixPosition.y + iwOffsetY - padY;
                }
                else if ((pixPosition.y + iwHeight + iwOffsetY + padY) > mapHeight) {
                    yOffset = pixPosition.y + iwHeight + iwOffsetY + padY - mapHeight;
                }
            }
            if (!(xOffset === 0 && yOffset === 0)) {
                // Move the map to the shifted center.
                //
                var c = map.getCenter();
                map.panBy(xOffset, yOffset);
            }
        }
    }
};
/**
 * Sets the style of the InfoBox by setting the style sheet and applying
 * other specific styles requested.
 * @private
 */
InfoBox.prototype.setBoxStyle_ = function () {
    var i, boxStyle;
    if (this.div_) {
        // Apply style values from the style sheet defined in the boxClass parameter:
        this.div_.className = this.boxClass_;
        // Clear existing inline style values:
        this.div_.style.cssText = "";
        // Apply style values defined in the boxStyle parameter:
        boxStyle = this.boxStyle_;
        for (i in boxStyle) {
            if (boxStyle.hasOwnProperty(i)) {
                this.div_.style[i] = boxStyle[i];
            }
        }
        // Fix for iOS disappearing InfoBox problem.
        // See http://stackoverflow.com/questions/9229535/google-maps-markers-disappear-at-certain-zoom-level-only-on-iphone-ipad
        this.div_.style.WebkitTransform = "translateZ(0)";
        // Fix up opacity style for benefit of MSIE:
        //
        if (typeof this.div_.style.opacity !== "undefined" && this.div_.style.opacity !== "") {
            // See http://www.quirksmode.org/css/opacity.html
            this.div_.style.MsFilter = "\"progid:DXImageTransform.Microsoft.Alpha(Opacity=" + (this.div_.style.opacity * 100) + ")\"";
            this.div_.style.filter = "alpha(opacity=" + (this.div_.style.opacity * 100) + ")";
        }
        // Apply required styles:
        //
        this.div_.style.position = "absolute";
        this.div_.style.visibility = 'hidden';
        if (this.zIndex_ !== null) {
            this.div_.style.zIndex = this.zIndex_;
        }
    }
};
/**
 * Get the widths of the borders of the InfoBox.
 * @private
 * @return {Object} widths object (top, bottom left, right)
 */
InfoBox.prototype.getBoxWidths_ = function () {
    var computedStyle;
    var bw = { top: 0, bottom: 0, left: 0, right: 0 };
    var box = this.div_;
    if (document.defaultView && document.defaultView.getComputedStyle) {
        computedStyle = box.ownerDocument.defaultView.getComputedStyle(box, "");
        if (computedStyle) {
            // The computed styles are always in pixel units (good!)
            bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;
            bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
            bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;
            bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;
        }
    }
    else if (document.documentElement.currentStyle) { // MSIE
        if (box.currentStyle) {
            // The current styles may not be in pixel units, but assume they are (bad!)
            bw.top = parseInt(box.currentStyle.borderTopWidth, 10) || 0;
            bw.bottom = parseInt(box.currentStyle.borderBottomWidth, 10) || 0;
            bw.left = parseInt(box.currentStyle.borderLeftWidth, 10) || 0;
            bw.right = parseInt(box.currentStyle.borderRightWidth, 10) || 0;
        }
    }
    return bw;
};
/**
 * Invoked when <tt>close</tt> is called. Do not call it directly.
 */
InfoBox.prototype.onRemove = function () {
    if (this.div_) {
        this.div_.parentNode.removeChild(this.div_);
        this.div_ = null;
    }
};
/**
 * Draws the InfoBox based on the current map projection and zoom level.
 */
InfoBox.prototype.draw = function () {
    this.createInfoBoxDiv_();
    var pixPosition = this.getProjection().fromLatLngToDivPixel(this.position_);
    this.div_.style.left = (pixPosition.x + this.pixelOffset_.width) + "px";
    if (this.alignBottom_) {
        this.div_.style.bottom = -(pixPosition.y + this.pixelOffset_.height) + "px";
    }
    else {
        this.div_.style.top = (pixPosition.y + this.pixelOffset_.height) + "px";
    }
    if (this.isHidden_) {
        this.div_.style.visibility = "hidden";
    }
    else {
        this.div_.style.visibility = "visible";
    }
};
/**
 * Sets the options for the InfoBox. Note that changes to the <tt>maxWidth</tt>,
 *  <tt>closeBoxMargin</tt>, <tt>closeBoxURL</tt>, and <tt>enableEventPropagation</tt>
 *  properties have no affect until the current InfoBox is <tt>close</tt>d and a new one
 *  is <tt>open</tt>ed.
 * @param {InfoBoxOptions} opt_opts
 */
InfoBox.prototype.setOptions = function (opt_opts) {
    if (typeof opt_opts.boxClass !== "undefined") { // Must be first
        this.boxClass_ = opt_opts.boxClass;
        this.setBoxStyle_();
    }
    if (typeof opt_opts.boxStyle !== "undefined") { // Must be second
        this.boxStyle_ = opt_opts.boxStyle;
        this.setBoxStyle_();
    }
    if (typeof opt_opts.content !== "undefined") {
        this.setContent(opt_opts.content);
    }
    if (typeof opt_opts.disableAutoPan !== "undefined") {
        this.disableAutoPan_ = opt_opts.disableAutoPan;
    }
    if (typeof opt_opts.maxWidth !== "undefined") {
        this.maxWidth_ = opt_opts.maxWidth;
    }
    if (typeof opt_opts.pixelOffset !== "undefined") {
        this.pixelOffset_ = opt_opts.pixelOffset;
    }
    if (typeof opt_opts.alignBottom !== "undefined") {
        this.alignBottom_ = opt_opts.alignBottom;
    }
    if (typeof opt_opts.position !== "undefined") {
        this.setPosition(opt_opts.position);
    }
    if (typeof opt_opts.zIndex !== "undefined") {
        this.setZIndex(opt_opts.zIndex);
    }
    if (typeof opt_opts.closeBoxMargin !== "undefined") {
        this.closeBoxMargin_ = opt_opts.closeBoxMargin;
    }
    if (typeof opt_opts.closeBoxURL !== "undefined") {
        this.closeBoxURL_ = opt_opts.closeBoxURL;
    }
    if (typeof opt_opts.infoBoxClearance !== "undefined") {
        this.infoBoxClearance_ = opt_opts.infoBoxClearance;
    }
    if (typeof opt_opts.isHidden !== "undefined") {
        this.isHidden_ = opt_opts.isHidden;
    }
    if (typeof opt_opts.visible !== "undefined") {
        this.isHidden_ = !opt_opts.visible;
    }
    if (typeof opt_opts.enableEventPropagation !== "undefined") {
        this.enableEventPropagation_ = opt_opts.enableEventPropagation;
    }
    if (this.div_) {
        this.draw();
    }
};
/**
 * Sets the content of the InfoBox.
 *  The content can be plain text or an HTML DOM node.
 * @param {string|Node} content
 */
InfoBox.prototype.setContent = function (content) {
    this.content_ = content;
    if (this.div_) {
        if (this.closeListener_) {
            google.maps.event.removeListener(this.closeListener_);
            this.closeListener_ = null;
        }
        // Odd code required to make things work with MSIE.
        //
        if (!this.fixedWidthSet_) {
            this.div_.style.width = "";
        }
        if (typeof content.nodeType === "undefined") {
            this.div_.innerHTML = this.getCloseBoxImg_() + content;
        }
        else {
            this.div_.innerHTML = this.getCloseBoxImg_();
            this.div_.appendChild(content);
        }
        // Perverse code required to make things work with MSIE.
        // (Ensures the close box does, in fact, float to the right.)
        //
        if (!this.fixedWidthSet_) {
            this.div_.style.width = this.div_.offsetWidth + "px";
            if (typeof content.nodeType === "undefined") {
                this.div_.innerHTML = this.getCloseBoxImg_() + content;
            }
            else {
                this.div_.innerHTML = this.getCloseBoxImg_();
                this.div_.appendChild(content);
            }
        }
        this.addClickHandler_();
    }
    /**
     * This event is fired when the content of the InfoBox changes.
     * @name InfoBox#content_changed
     * @event
     */
    google.maps.event.trigger(this, "content_changed");
};
/**
 * Sets the geographic location of the InfoBox.
 * @param {LatLng} latlng
 */
InfoBox.prototype.setPosition = function (latlng) {
    this.position_ = latlng;
    if (this.div_) {
        this.draw();
    }
    /**
     * This event is fired when the position of the InfoBox changes.
     * @name InfoBox#position_changed
     * @event
     */
    google.maps.event.trigger(this, "position_changed");
};
/**
 * Sets the zIndex style for the InfoBox.
 * @param {number} index
 */
InfoBox.prototype.setZIndex = function (index) {
    this.zIndex_ = index;
    if (this.div_) {
        this.div_.style.zIndex = index;
    }
    /**
     * This event is fired when the zIndex of the InfoBox changes.
     * @name InfoBox#zindex_changed
     * @event
     */
    google.maps.event.trigger(this, "zindex_changed");
};
/**
 * Sets the visibility of the InfoBox.
 * @param {boolean} isVisible
 */
InfoBox.prototype.setVisible = function (isVisible) {
    this.isHidden_ = !isVisible;
    if (this.div_) {
        this.div_.style.visibility = (this.isHidden_ ? "hidden" : "visible");
    }
};
/**
 * Returns the content of the InfoBox.
 * @returns {string}
 */
InfoBox.prototype.getContent = function () {
    return this.content_;
};
/**
 * Returns the geographic location of the InfoBox.
 * @returns {LatLng}
 */
InfoBox.prototype.getPosition = function () {
    return this.position_;
};
/**
 * Returns the zIndex for the InfoBox.
 * @returns {number}
 */
InfoBox.prototype.getZIndex = function () {
    return this.zIndex_;
};
/**
 * Returns a flag indicating whether the InfoBox is visible.
 * @returns {boolean}
 */
InfoBox.prototype.getVisible = function () {
    var isVisible;
    if ((typeof this.getMap() === "undefined") || (this.getMap() === null)) {
        isVisible = false;
    }
    else {
        isVisible = !this.isHidden_;
    }
    return isVisible;
};
/**
 * Shows the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]
 */
InfoBox.prototype.show = function () {
    this.isHidden_ = false;
    if (this.div_) {
        this.div_.style.visibility = "visible";
    }
};
/**
 * Hides the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]
 */
InfoBox.prototype.hide = function () {
    this.isHidden_ = true;
    if (this.div_) {
        this.div_.style.visibility = "hidden";
    }
};
/**
 * Adds the InfoBox to the specified map or Street View panorama. If <tt>anchor</tt>
 *  (usually a <tt>google.maps.Marker</tt>) is specified, the position
 *  of the InfoBox is set to the position of the <tt>anchor</tt>. If the
 *  anchor is dragged to a new location, the InfoBox moves as well.
 * @param {Map|StreetViewPanorama} map
 * @param {MVCObject} [anchor]
 */
InfoBox.prototype.open = function (map, anchor) {
    var me = this;
    if (anchor) {
        this.position_ = anchor.getPosition();
        this.moveListener_ = google.maps.event.addListener(anchor, "position_changed", function () {
            me.setPosition(this.getPosition());
        });
    }
    this.setMap(map);
    if (this.div_) {
        this.panBox_();
    }
};
/**
 * Removes the InfoBox from the map.
 */
InfoBox.prototype.close = function () {
    var i;
    if (this.closeListener_) {
        google.maps.event.removeListener(this.closeListener_);
        this.closeListener_ = null;
    }
    if (this.eventListeners_) {
        for (i = 0; i < this.eventListeners_.length; i++) {
            google.maps.event.removeListener(this.eventListeners_[i]);
        }
        this.eventListeners_ = null;
    }
    if (this.moveListener_) {
        google.maps.event.removeListener(this.moveListener_);
        this.moveListener_ = null;
    }
    if (this.contextListener_) {
        google.maps.event.removeListener(this.contextListener_);
        this.contextListener_ = null;
    }
    this.setMap(null);
};
var markers = function () { };
markers.markersIndexes = [];
markers.markersEntities = [];
markers.clusterUssage = false;
markers.enableCluster = function () {
    markers.clusterUssage = true;
    return markers;
};
markers.disableCluster = function () {
    markers.clusterUssage = false;
    return markers;
};
markers.createMarker = function (item, map) {
    var content = "<div id='onMap-" + item.id + "'><span class='markerCur'>&euro;</span>" + item.price + "</div><div class='markerArrow'></div>";
    var labelClass = 'labels';
    if (item.markerViewed) {
        labelClass += ' visited';
    }
    var marker = new MarkerWithLabel({
        position: new google.maps.LatLng(item.lat, item.lng),
        map: map,
        title: item.name,
        raiseOnDrag: true,
        labelContent: content,
        labelAnchor: new google.maps.Point(3, 30),
        labelClass: labelClass
    });
    markers.addToChache(marker)
        .createInfowindow(marker, item, map);
    if (markers.clusterUssage) {
        markers.addToCluster(marker, map);
    }
};
markers.removeMarkers = function () {
    for (var i = 0; i < markers.markersEntities.length; i++) {
        markers.markersEntities[i].setMap(null);
    }
    markers.markersIndexes = [];
    markers.markersEntities = [];
    if (markers.clusterUssage) {
        markers.getCluster().clearMarkers();
    }
    return markers;
};
markers.addToChache = function (marker) {
    markers.markersEntities.push(marker);
    markers.markersIndexes.push(markers.generateIndexForMarker(marker));
    return markers;
};
markers.markerCluster = null;
markers.addToCluster = function (marker, map) {
    markers.getCluster(map).addMarker(marker);
    return markers;
};
markers.getCluster = function (map) {
    if (markers.markerCluster === null)
        markers.markerCluster = new MarkerClusterer(map, [], {
            gridSize: 50,
            maxZoom: 15,
            styles: [
                {
                    textColor: 'white',
                    url: '/images/realties/objects/map/m1.png',
                    height: 53,
                    width: 52
                },
                {
                    textColor: 'white',
                    url: '/images/realties/objects/map/m1.png',
                    height: 53,
                    width: 52
                },
                {
                    textColor: 'white',
                    url: '/images/realties/objects/map/m1.png',
                    height: 53,
                    width: 52
                }
            ]
        });
    return markers.markerCluster;
};
markers.generateIndexForMarker = function (marker) {
    return marker.getPosition().lat() + marker.getPosition().lng();
};
markers.isExists = function (marker) {
    return markers.markersEntities.indexOf(markers.generateIndexForMarker(marker)) !== -1;
};
markers.isExistsByLatLng = function (lat, lng) {
    var latLng = new google.maps.LatLng(lat, lng);
    return (markers.markersIndexes.indexOf(latLng.lat() + latLng.lng()) !== -1);
};
markers.getMarkersEntities = function () {
    return markers.markersEntities;
};
markers.infoboxes = [];
markers.createInfowindow = function (marker, data, map) {
    var infobox = new InfoBox({
        content: markers.getInfowindowHtml(data),
        pixelOffset: new google.maps.Size(-136, -277),
        onOpen: function () {
        }
    });
    markers.infoboxes.push(infobox);
    google.maps.event.addListener(marker, 'click', function () {
        markers.setMarkersZIndex(marker)
            .closeWindows();
        infobox.open(map, marker);
        markers.setVisited(marker, data);
    });
    return markers;
};
markers.setVisited = function (marker, data) {
    $.post('/realties/ajaxRememberMarker/', { 'id': data.id }, function () {
        marker.set("labelClass", "labels visited");
    });
};
markers.setMarkersZIndex = function (marker) {
    $(markers.getMarkersEntities()).each(function () {
        this.setZIndex(google.maps.Marker.MAX_ZINDEX);
    });
    marker.setZIndex(google.maps.Marker.MAX_ZINDEX + 1);
    return markers;
};
markers.closeWindows = function () {
    $.each(markers.infoboxes, function () {
        this.close();
    });
};
markers.getInfowindowHtml = function (data) {
    var parameters = '';
    $.each(data.parameters, function () {
        parameters += '<img src="/images/realties/objects/parameters_ico/' + this + '.svg" alt="">';
    });
    var image = '<a href="' + data.url + '" target="_blank">' +
        '<img src="' + data.images[0].image + '" alt="">' +
        '</a>';
    var content = '' +
        '<div class="overlayOffers">' +
        '<div class="arrowBlock"></div>' +
        '<div class="overlayImgOffers">' +
        '<div class="overlayViewport touchslider">' +
        '<div class="touchslider-viewport"><div>' +
        image +
        '</div></div>' +
        '</div>' +
        '<div class="iconInfo">' +
        parameters +
        '</div>' +
        '<a ' +
        '   class="addToFavorites toFavorites" ' +
        '   data-action="/realties/ajaxSetFavorite/" ' +
        '   data-post="id=' + data.id + '" ' +
        '   data-method="post" ' +
        '></a>' +
        '</div>' +
        '<div class="dataOffers">' +
        '<a href="' + data.url + '" class="linkTitle" target="_blank">' +
        data.name +
        '<div class="fffColor2"></div>' +
        '</a>' +
        '<span class="addressName">' +
        data.category +
        '</span>' +
        '<span class="infoIcon">' +
        '<span><img src="/images/realties/mapInfowindow/man.svg" title="" alt=""></span>' +
        '<span class="figures">' + data.guests + '</span>' +
        '<span><img src="/images/realties/mapInfowindow/door.svg" title="" alt=""></span>' +
        '<span class="figures">' + data.rooms + '</span>' +
        '<span><img src="/images/realties/mapInfowindow/bed.svg" title="" alt=""></span>' +
        '<span class="figures">' + data.beds + '</span>' +
        '</span>' +
        '<div class="priceOffers">' +
        '<div class="presentDayPrice">' +
        '<span>€</span>' + data.price +
        '</div>' +
        '</div>' +
        '<div class="clear"></div>' +
        '</div>' +
        '</div>';
    return content;
};
var realtiesOnMap = function () { };
realtiesOnMap.map;
realtiesOnMap.loader = new loaderBlock('/images/loaders/vput/xxs.gif');
realtiesOnMap.loader.init($('.mapSync'));
realtiesOnMap.getMarkerById = function (markerId) {
    var index = markers.markersIndexes.indexOf(markerId);
    return markers.markersEntities[index];
};
realtiesOnMap.createMarker = function (item) {
    if (markers.isExistsByLatLng(item.lat, item.lng))
        return;
    markers.createMarker(item, realtiesOnMap.map);
};
realtiesOnMap.setCenter = function (city) {
    if (typeof hashHandler.getJsonHash().mapCenter == 'undefined') {
        if (realtiesOnMap.isLatLngExistsInObject(city)) {
            realtiesOnMap.setCenterByLatLng(new google.maps.LatLng(parseFloat(city.lat), parseFloat(city.lng)));
        }
        else {
            realtiesOnMap.setCenterByObjectName(city.name);
        }
    }
    else {
        var lat = hashHandler.getJsonHash().mapCenter.split('x')[0];
        var lng = hashHandler.getJsonHash().mapCenter.split('x')[1];
        realtiesOnMap.setCenterByLatLng(new google.maps.LatLng(lat, lng));
    }
    return realtiesOnMap;
};
realtiesOnMap.isLatLngExistsInObject = function (object) {
    return ((object.lat != '' && object.lng != '') && (typeof object.lat !== 'undefined' && typeof object.lng !== 'undefined'));
};
realtiesOnMap.setCenterByObjectName = function (objectName) {
    if (typeof objectName != 'string')
        return realtiesOnMap;
    var geocoder = new google.maps.Geocoder();
    geocoder.geocode({ 'address': objectName }, function (results, status) {
        if (status == google.maps.GeocoderStatus.OK) {
            realtiesOnMap.map.setCenter(results[0].geometry.location);
        }
    });
    return realtiesOnMap;
};
realtiesOnMap.setCenterByLatLng = function (latLng) {
    realtiesOnMap.map.setCenter(latLng);
};
realtiesOnMap.initialize = function () {
    realtiesOnMap.map = new google.maps.Map(document.getElementById('map-canvas'), {
        maxZoom: mapsZoomer.settings.maxZoom,
        minZoom: mapsZoomer.settings.minZoom,
        scrollwheel: false,
        zoomControl: false,
        streetViewControl: false,
        scaleControl: false,
        panControl: false,
        mapTypeControl: false,
        zIndex: 1
    });
    $(window).resize(function () {
        google.maps.event.trigger(realtiesOnMap.map, "resize");
    });
    google.maps.event.addListener(realtiesOnMap.map, 'dragend', realtiesOnMap.reloadRealties);
    google.maps.event.addListener(realtiesOnMap.map, 'zoom_changed', realtiesOnMap.reloadRealties);
    google.maps.event.addListener(realtiesOnMap.map, 'zoom_changed', realtiesOnMap.setCurrentZoom);
    realtiesOnMap.setSyncCheckbox();
    return realtiesOnMap;
};
realtiesOnMap.setCurrentZoom = function () {
    var zoomer = mapsZoomer(realtiesOnMap.map);
    zoomer.current = realtiesOnMap.map.getZoom();
};
realtiesOnMap.reloadRealties = function () {
    if (!realtiesOnMap.isSyncWithList())
        return;
    var bounds = realtiesOnMap.map.getBounds();
    if (typeof bounds != 'undefined') {
        var center = realtiesOnMap.map.getCenter();
        var ne = bounds.getNorthEast();
        var sw = bounds.getSouthWest();
        $('#neLat').val(ne.lat());
        $('#neLng').val(ne.lng());
        $('#swLat').val(sw.lat());
        $('#swLng').val(sw.lng());
        $('#mapCenter').val(center.lat() + 'x' + center.lng());
        realtiesOnMap.startLoader();
        filtersForm.startSearchByMap();
    }
    return realtiesOnMap;
};
realtiesOnMap.isSyncWithList = function () {
    return $('#mapSync').is(':checked');
};
realtiesOnMap.setSyncCheckbox = function () {
    if (typeof hashHandler.getJsonHash().mapCenter != 'undefined') {
        $('#mapSync').attr('checked', 'true');
    }
};
realtiesOnMap.setTiles = function () {
    realtiesOnMap.map.overlayMapTypes.insertAt(0, new realtiesOnMap.serverFetchMapType());
    return realtiesOnMap;
};
realtiesOnMap.setZoom = function (zoom) {
    var zoomer = mapsZoomer(realtiesOnMap.map);
    zoomer.setZoom(zoom);
    return realtiesOnMap;
};
realtiesOnMap.serverFetchedTiles = [];
realtiesOnMap.serverFetchMapType = function () { };
realtiesOnMap.serverFetchMapType.prototype.tileSize = new google.maps.Size(256, 256);
realtiesOnMap.serverFetchMapType.prototype.maxZoom = 16;
realtiesOnMap.serverFetchMapType.prototype.getTile = function (coord, zoom, ownerDocument) {
    var addr = this.getLatLng(coord, zoom);
    var div = ownerDocument.createElement('div');
    div.style.width = this.tileSize.width + 'px';
    div.style.height = this.tileSize.height + 'px';
    if (realtiesOnMap.serverFetchedTiles[addr]) {
        return div;
    }
    $.get("/loadMapTile?" + addr, function (data) {
        realtiesOnMap.serverFetchedTiles[addr] = data;
        realtiesOnMap.createMarkers(data);
    });
    return div;
};
realtiesOnMap.query = '';
realtiesOnMap.setQuery = function (query) {
    realtiesOnMap.query = query;
    return realtiesOnMap;
};
realtiesOnMap.getQuery = function () {
    if (realtiesOnMap.query) {
        return '&' + realtiesOnMap.query;
    }
    return realtiesOnMap.query;
};
realtiesOnMap.reset = function () {
    markers.removeMarkers();
    return realtiesOnMap;
};
realtiesOnMap.createMarkers = function (data) {
    $.each(data, function () {
        markers.createMarker(this);
    });
};
realtiesOnMap.serverFetchMapType.prototype.getAddrLatLng = function (coord, zoom) {
    var point1 = {
        x: coord.x,
        y: coord.y,
        z: zoom
    };
    var point2 = {
        x: (coord.x + 1),
        y: (coord.y + 1),
        z: zoom
    };
    var ne = realtiesOnMap.getLatLngByPoint(point1);
    var sw = realtiesOnMap.getLatLngByPoint(point2);
    return "NE=" + ne.toString() + "&SW=" + sw.toString() + "&z=" + zoom + realtiesOnMap.getQuery();
};
realtiesOnMap.serverFetchMapType.prototype.getLatLng = function (coord, zoom) {
    var point1 = {
        x: coord.x,
        y: coord.y,
        z: zoom
    };
    var point2 = {
        x: (coord.x + 1),
        y: (coord.y + 1),
        z: zoom
    };
    var ne = realtiesOnMap.getLatLngByPoint(point1);
    var sw = realtiesOnMap.getLatLngByPoint(point2);
    return "neLat=" + ne.lat() + "&neLng=" + ne.lng() + "&swLat=" + sw.lat() + "&swLng=" + sw.lng() + "&z=" + zoom + realtiesOnMap.getQuery();
};
realtiesOnMap.showGridMarker = function (point) {
    new google.maps.Marker({
        position: realtiesOnMap.getLatLngByPoint(point),
        map: realtiesOnMap.map,
        title: 'Test marker'
    });
};
realtiesOnMap.getLatLngByPoint = function (point) {
    return new google.maps.LatLng(this.tile2lat(point.y, point.z), this.tile2lng(point.x, point.z));
};
realtiesOnMap.tile2lng = function (x, z) {
    return (x / Math.pow(2, z) * 360 - 180);
};
realtiesOnMap.tile2lat = function (y, z) {
    var n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);
    return (180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))));
};
realtiesOnMap.startLoader = function () {
    if (realtiesOnMap.isSyncWithList()) {
        realtiesOnMap.loader.start();
    }
};
realtiesOnMap.stopLoader = function () {
    if (realtiesOnMap.isSyncWithList()) {
        realtiesOnMap.loader.stop();
    }
};
$(function () {
    $(window).load(function () {
        MGoals = new MetrikaGoals();
        MGoals.reachGoal(8);
    });
});
var mapsZoomer = function (map) {
    mapsZoomer.map = map;
    return mapsZoomer;
};
mapsZoomer.settings = {
    'maxZoom': 21,
    'minZoom': 10
};
mapsZoomer.current = 13;
mapsZoomer.zoomIn = function () {
    if (mapsZoomer.isValid(mapsZoomer.current + 1)) {
        mapsZoomer.setZoom(mapsZoomer.current + 1);
    }
};
mapsZoomer.zoomOut = function () {
    if (mapsZoomer.isValid(mapsZoomer.current - 1)) {
        mapsZoomer.setZoom(mapsZoomer.current - 1);
    }
};
mapsZoomer.setZoom = function (zoom) {
    mapsZoomer.map.setZoom(zoom);
    mapsZoomer.current = zoom;
    hashHandler.setItem('zoom', zoom);
};
mapsZoomer.isValid = function (zoom) {
    return zoom <= mapsZoomer.settings.maxZoom && zoom >= mapsZoomer.settings.minZoom;
};
mapsZoomer.isMax = function () {
    return mapsZoomer.current >= mapsZoomer.settings.maxZoom;
};
mapsZoomer.isMin = function () {
    return mapsZoomer.current <= mapsZoomer.settings.minZoom;
};
jQuery(document).ready(function ($) {
    var blockElement = $('.reviews-slider');
    blockElement.slick();
});
jQuery(document).ready(function ($) {
    var blockElement = $('.authorization'), cardFront = blockElement.find('.authorization__card-front');
    cardFront.on('click', function () {
        cardFront.toggleClass('d-none');
    });
});
jQuery(document).ready(function ($) {
    var blockElement = $('.photos-of-the-complex');
    blockElement.find('.photos-of-the-complex__slider[is-slick-carousel]').slick();
});
jQuery(document).ready(function ($) {
    var blockElement = $('.who-we-are');
    blockElement.find('.popular-cities__link').on('click', function (e) {
        e.preventDefault();
        var data = $(this).data();
        blockElement.find('.form-search-offers__cities-tabs-toggle').val(data.name);
        blockElement.find('.form-search-offers__cities-dropdown').collapse('hide');
        blockElement.find('[name="filters[cityId]"]').val(data.id);
    });
});
jQuery(document).ready(function ($) {
    var blockElement = $('.form-car-rental');
    blockElement.on('submit', function (e) {
        e.preventDefault();
        var isValidForm = blockElement[0].checkValidity();
        function hideAlerts() {
            setTimeout(function () {
                blockElement.find('.form-car-rental__alert').fadeOut();
            }, 5000);
        }
        if (isValidForm) {
            $.ajax({
                url: blockElement.attr('action'),
                method: blockElement.attr('method'),
                data: blockElement.serialize()
            })
                .done(function () {
                blockElement[0].reset();
                blockElement.find('.form-car-rental__alert_is_success')
                    .removeClass('d-none')
                    .css('display', 'none')
                    .fadeIn();
                hideAlerts();
            })
                .fail(function () {
                blockElement.find('.form-car-rental__alert_is_danger')
                    .removeClass('d-none')
                    .css('display', 'none')
                    .fadeIn();
                hideAlerts();
            });
        }
    });
});
jQuery(document).ready(function ($) {
    var blockElement = $('.form-feedback');
    blockElement.on('submit', function (e) {
        e.preventDefault();
        var isValidForm = blockElement[0].checkValidity();
        function hideAlerts() {
            setTimeout(function () {
                blockElement.find('.form-feedback__alert').fadeOut();
            }, 5000);
        }
        if (isValidForm) {
            $.ajax({
                url: blockElement.attr('action'),
                method: blockElement.attr('method'),
                data: blockElement.serialize()
            })
                .done(function () {
                blockElement[0].reset();
                blockElement.find('.form-feedback__alert_is_success')
                    .removeClass('d-none')
                    .css('display', 'none')
                    .fadeIn();
                hideAlerts();
            })
                .fail(function () {
                blockElement.find('.form-feedback__alert_is_danger')
                    .removeClass('d-none')
                    .css('display', 'none')
                    .fadeIn();
                hideAlerts();
            });
        }
    });
});
document.addEventListener('DOMContentLoaded', function () {
    var blockElement = $('.form-search-offers');
    blockElement.find('.cities-tabs__link').on('click', function (e) {
        e.preventDefault();
        var data = $(this).data(), toggleCollapseElement = blockElement.find('.form-search-offers__cities-tabs-toggle');
        toggleCollapseElement.val(data.name);
        blockElement.find('[name="filters[cityId]"]').val(data.id);
        toggleCollapseElement.trigger('click');
    });
    blockElement
        .find('.form-search-offers__list-of-cities-toggle')
        .on('click', function () {
        var cityNameInputElement = $(this), cityIdInputElement = blockElement.find('[name="filters[cityId]"]'), listOfCitiesElement = blockElement.find('.list-of-cities');
        listOfCitiesElement.toggleClass('d-none');
        listOfCitiesElement.find('.list-of-cities__nav > .nav-link').on('click', function (e) {
            console.log('Clicked on city');
            e.preventDefault();
            var that = $(this);
            cityNameInputElement.val(that.data('name'));
            cityIdInputElement.val(that.data('id'));
        });
    });
    var sliderElement = blockElement.find('.form-search-offers__slider').get(0), minPriceElement = blockElement.find('[name="filters[prices][minPrice]"]').get(0), maxPriceElement = blockElement.find('[name="filters[prices][maxPrice]"]').get(0), inputs = [minPriceElement, maxPriceElement], minPrice = sliderElement.dataset.min ? sliderElement.dataset.min * 1 : 0, maxPrice = sliderElement.dataset.max ? sliderElement.dataset.max * 1 : 1000;
    noUiSlider.create(sliderElement, {
        start: [minPrice, maxPrice],
        connect: true,
        tooltips: true,
        range: {
            'min': minPrice,
            'max': maxPrice
        },
        format: wNumb({
            decimals: 0,
            prefix: '€'
        })
    });
    sliderElement.noUiSlider.on('update', function (values, handle) {
        inputs[handle].value = values[handle];
    });
}, false);

//# sourceMappingURL=ts.bundle.min.js.map
